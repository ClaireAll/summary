- [1. React/Vue列表为什么要key](#1-reactvue列表为什么要key)
- [2. \['1', '2', '3'\].map(parseInt)](#2-1-2-3mapparseint)
- [3. 防抖与节流的区别](#3-防抖与节流的区别)
- [4. Set、Map、WeakSet、WeakMap的区别](#4-setmapweaksetweakmap的区别)
- [5. 深度优先遍历|广度优先遍历](#5-深度优先遍历广度优先遍历)
- [6. es5/es6 除了写法还有什么区别](#6-es5es6-除了写法还有什么区别)
- [7. JS异步解决方案的发展历程](#7-js异步解决方案的发展历程)


### 1. React/Vue列表为什么要key
> key是给每个node的唯一id，可以依靠key更快地拿到oldVnode中对应的node节点

### 2. ['1', '2', '3'].map(parseInt)
> [1, NaN, NaN]
> map的第一个参数是callback，这个callback可以接收3个参数（当前被处理的元素，该元素的索引）
> arr.map(callback(value: T, index: number, array: T[]) => U, thisArg?:any)
> parseInt是用来解析字符串的，使字符串成为指定基数的整数，接收两个参数（被处理的值，解析时的基数）
> parseInt(string, radix)
> parseInt('1', 0) 按照10为基数处理
> parseInt('2', 1) 1进制，无法解析2，返回NaN
> parseInt('3', 2) 2进制，无法解析3，返回NaN

### 3. 防抖与节流的区别
+ 防抖：触发高频时间后n秒内函数只执行一次，n秒内高频时间再次触发，重新计算时间
``` javascript
    function debounce (fn) {
        let timeout = null; // 创建一个标记用来存放定时器的返回值
        return function () {
            clearTimeout(timeout); // 每当输入的时候把前一个clear掉
            timeout = setTimeout(() => {
                fn.apply(this, arguments);
            }, 500); // 保证字符输入后500ms内如果还有字符输入的话，就不会执行fn函数
        }
    }
```
+ 节流：高频事件触发，n秒内只执行一次，所以节流会稀释函数的执行频率
``` javascript
    function throttle (fn) {
        let canRun = true;
        return function () {
            if (!canRun) return;
            canRun = false;
            setTimeout(() => {
                fn.apply(this, arguments);
                canRun = true;
            }, 500);
        }
    }
```

### 4. Set、Map、WeakSet、WeakMap的区别
+ Set  对象允许你存储任何类型的唯一只，无论是原始值或者是对象引用
+ WeakSet  对象都是成员：成员都是弱引用，可以被垃圾回收机制回收，可以用来保存DOM节点，不容易造成内存泄露
+ Map  本质上是键值对的集合，类似集合：可以遍历，方法很多，可以根据各种数据格式转换
+ WeakMap  只接受对象为键名（null除外），不接受其它类型的值作为键名：键名是弱引用，键值可以是任意的，键名所指向的对象可以被垃圾回收，此时键名无效。不能遍历。方法有get、set、has、delete

### 5. 深度优先遍历|广度优先遍历
+ 深度优先遍历：从某个顶点出发，首先访问这个顶点，然后找出这个顶点的第一个未被访问的邻结点，再以此为顶点，继续找下一个，直到所有结点被访问完。
+ 广度优先遍历：从某个顶点出发，首先访问这个顶点，然后找出这个顶点的所有被访问的邻结点，访问完后再访问这些结点中第一个邻结点的所有结点，重复此方法，直到所有结点都被访问完为止。

深度优先遍历
```javascript
// 递归
function deepTraversal(node) {
    let nodes = [];
    if (node !== null) {
        nodes.push(node);
        let children = node.children;
        for (let i = 0; i < children.length; i++) {
            deepTraversal(children[i]);
        }
    }

    return nodes;
}

// 非递归
function deepTraversal(node) {
    let nodes = [];
    if (node !== null) {
        let stack = [];  // 用来存放将要访问的节点
        stack.push[node];
        while (stack.length !== 0) {
            let item = stack.pop();
            nodes.push(item); // 正在访问的节点
            let children = item.children;

            for (let i = children.length - 1; i >= 0; i--) {
                stack.push(children[i]);
            }
        }
    }

    return nodes;
}
```

广度优先遍历
```javascript
// 递归
function wideTraversal(node) {
    let nodes = [], i = 0;
    if (node !== null) {
        nodes.push(node);
        wideTraversal(node.nextElementSibling);
        node = nodes[i++];
        wideTraversal(node.nextElementSibling);
    }

    return nodes;
}

// 非递归
function wideTraversal(node) {
    let nodes = [], i = 0;
    while (node !== null) {
        nodes.push(node);
        node = nodes[i++];
        let children = node.children;
        for (let i = 0; i < children.length; i++) {
            nodes.push(children[i]);
        }
    }

    return nodes;
}
```

### 6. es5/es6 除了写法还有什么区别
+ > es5的继承实质上是先创建子类的实例对象，然后再将父类的方法添加到this上（Parent.apply(this)）
+ > es6的继承机制完全不同，实质上是先创建父类的实例对象this（所以必须先调用父类的super()方法），然后再用子类的构造函数修改this
+ > es5的继承是通过原型或构造函数机制来实现
+ > es6通过class关键字定义类，里面有构造方法，类之间通过extends关键字实现继承
+ > 子类必须在constructor方法中调用super方法，否则新建实例报错。因为子类有没有增肌的this对象，而是继承了父类的this对象，然后对齐进行加工。如果不调用super，子类得不到this对象。
+ > super关键字指代父类的实例，即父类的this对象
+ > 在子类构造函数中，调用super后才可以使用this关键字，否则报错

### 7. JS异步解决方案的发展历程
1. 回调函数callback
   > 优点：解决了同步问题
   > 缺点：回调地域，不能用try catch捕获错误，不能return

2. Promise
   > 优点：解决了回调地域
   > 缺点：无法取消Promise，错误需要通过回调函数来获取

3. Generator
   > 特点：可以控制函数的执行，可以配合co函数库使用

4. Async/await
   > 优点：代码清晰，处理了回调地域
   > 缺点：将异步代码改成了同步代码，如果多个异步操作没有依赖性，使用await会降低性能。